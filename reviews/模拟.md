# 模拟类题目
## LC.592 分数加减运算
> https://leetcode.cn/problems/fraction-addition-and-subtraction/

```java
class Solution {
    public String fractionAddition(String expression) {
        long numerator=1;
        long denominator=0;
        int n=expression.length();
        int index=0;

        while(index<n){
            //每次都设定新读入的分子与分母
            //设定新分子为0；
            long denominator1=0;
            long sign=1;
            //读取新分子的符号
            if(expression.charAt(index)=='+' || expression.charAt(index)=='-'){
                sign = expression.charAt(index)=='-'? -1:1;
                index++;
            }
            //计算新分子的值
            while(index<n && Character.isDigit(expression.charAt(index))){
                denominator1=denominator1*10+expression.charAt(index)-'0';
                index++;
            }
            denominator1=sign*denominator1;
            index++;
            //设定新分母为0;
            long numerator1=0;
            while(index<n && Character.isDigit(expression.charAt(index))){
                numerator1=numerator1*10+expression.charAt(index)-'0';
                index++;
            }
            //以上读完了一个完整的分数，计算目前的和
            denominator=denominator1*numerator+denominator*numerator1;
            numerator *=numerator1;
        }

        if(denominator==0){
            return "0/1";
        }

        long g=gcd(Math.abs(denominator),numerator);
        return Long.toString(denominator/g)+"/"+Long.toString(numerator/g);
    }

    public long gcd(long a, long b){
        long remains=a%b;
        while(remains!=0){
            a=b;
            b=remains;
            remains=a%b;
        }
        return b;
    }
}
```
## LC.593 有效的正方形
> https://leetcode.cn/problems/valid-square/

```java
class Solution {
    long len=-1;
    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {
        return isorthtri(p1,p2,p3) && isorthtri(p2,p3,p4) && isorthtri(p1,p2,p4) && isorthtri(p1,p3,p4);
    }

    boolean isorthtri(int[] a, int[] b, int[] c){
        long s1=(a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1]);
        long s2=(a[0]-c[0])*(a[0]-c[0])+(a[1]-c[1])*(a[1]-c[1]);
        long s3=(b[0]-c[0])*(b[0]-c[0])+(b[1]-c[1])*(b[1]-c[1]);
        boolean ok=(s1==s2 && s1+s2==s3) || (s1==s3 && s1+s3==s2) || (s2==s3 && s2+s3==s1);
        if(!ok){
            return false;
        }
        if(len==-1){
            len=Math.min(s1,s2);
        }else if(len==0 || len!=Math.min(s1,s2)){
            return false;
        }
        return true;
    }
}
```
