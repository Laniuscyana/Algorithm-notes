# 链表


## LC.21 合并两个链表
> https://leetcode.cn/problems/merge-two-sorted-lists/
 ```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1 == null || list2 == null){
            return list1==null?list2:list1;
        }
        ListNode pans=new ListNode(-1);
        ListNode cur=pans;
        while(list1 != null && list2 != null){
            if(list1.val<=list2.val){
                cur.next=list1;
                list1=list1.next;
            }else{
                cur.next=list2;
                list2=list2.next;
            }
            cur=cur.next;
        }
        cur.next= list1==null?list2:list1;
        return pans.next;
    }
}
```
## LC.25 翻转k个链表
> https://leetcode.cn/problems/reverse-nodes-in-k-group/

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode start=head;
        ListNode end=getEnd(start,k);
        if(end==null){
          return head;
        }
        head=end;
        reversegroup(start,end);
        ListNode lastEnd=start;
        while(lastEnd!=null){
            start=lastEnd.next;
            end=getEnd(start,k);
            if(end==null){
                return head;
            }
            reversegroup(start,end);
            lastEnd.next=end;
            lastEnd=start;
        }
        return head;
    }
    
    public ListNode reversegroup(ListNode start,ListNode end){
        end=end.next;
        ListNode pre=null;
        ListNode cur=start;
        ListNode next=null;
        while(cur!=end){
           next=cur.next;
           cur.next=pre;
           pre=cur;
           cur=next;
        }
        start.next=end;
        return cur;
    }
    
    public ListNode getEnd(ListNode start, int k){
        while(--k!=0 && start!=null){
            start=start.next;    
        }
        return start;
     }
}
```

## LC.206 链表反转
> https://leetcode.cn/problems/reverse-linked-list/

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        //新建一个节点prev，该节点将从null开始，从原头节点遍历到尾部，作为新的头节点返回
        ListNode prev=null;
        
        while(head!=null){
            //令一个新的临时储存原头节点的指针先指向原头节点的下一个节点
            ListNode p=head.next;
            //然后令原头节点指向prev，此时prev为空
            head.next=prev;
            //接着令目前的prev为头节点
            prev=head;
            //最后，令头节点为刚才的临时储存头节点下一个位置的节点p，即往原头节点的位置的下一个位置挪动
            head=p;
            //   1-> 2 ->3  prev (null)
            // head  p 

            // null<-1    2->3
            // prev head  p 

            // null<-1    2->3
            //     prev   p
            //     head

            // null<-1    2->3
            //     prev   p
            //           head

            // null<-1   2  ->  3
            //    prev  head    p

            // null<-1 <-2      3
            //    prev  head    p

            // null<-1 <-2      3
            //          head    p
            //          prev

            // null<-1 <-2      3
            //          prev    p
            //                 head
            // listnode newnode=head.next,aimed to store head's next node,'cause once the node is changed its pionter, the next node cannot be found and would be relased by jvm. and then head.next=prev, aimed to changed the pointer of the head. for the very start, prev is null. then came to prev=head and head=p, aimed to prepare for next iteration. p pointer is used as storeage for head, and prev pointer is used as new head and new nodes. 
        }
        return prev;
    }
```

## LC.234 回文链表
> https://leetcode.cn/problems/palindrome-linked-list/
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head==null){
            return true;
        }

        ListNode firstend=findSecondHalf(head);
        ListNode halfrevend=reverseList(firstend.next);

        ListNode p1=head;
        ListNode p2=halfrevend;

        boolean res=true;

        while(res && p2!=null){
            if(p1.val!=p2.val){
                res=false;
            }
            p1=p1.next;
            p2=p2.next;
        }

        firstend.next=reverseList(halfrevend);
        return res;
    }

    public ListNode reverseList(ListNode head){
        ListNode prev=null;
        ListNode curr=head;
        while(curr!=null){
            ListNode nexttemp=curr.next;
            curr.next=prev;
            prev=curr;
            curr=nexttemp;
        }
        return prev;
    }

    public ListNode findSecondHalf(ListNode head){
        ListNode fast=head;
        ListNode slow=head;
        while(fast.next!=null && fast.next.next!=null){
            fast=fast.next.next;
            slow=slow.next;
        }
        return slow;
    }
}
```

## 剑指offer：排序的循环链表
> https://leetcode.cn/problems/4ueAj6/

思路：第一步，生成一个环状节点，并加入边界条件判定：头节点是否为空，如果为空，那么返回新生成的节点，此时一定满足题目要求：单调非递减。

第二步，生成ans，储存原头节点。

第三步，第一次遍历整个链表，找出节点的最大值与最小值。

第四步，第二次遍历整个链表，

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node next;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _next) {
        val = _val;
        next = _next;
    }
};
*/

class Solution {
    public Node insert(Node head, int insertVal) {
        //生成一个环状节点，并判断边界条件：头节点是否为空，如果为空返回新生成的节点，因为此时一定满足单调非减；
        Node t=new Node(insertVal);
        t.next=t;
        if(head==null){
            return t;
        }

        //生成ans储存原本的头节点
        Node ans=head;

        //一次遍历，找出节点中最大和最小值
        int min=head.val;
        int max=head.val;
        while(head.next!=ans){
            head=head.next;
            min=Math.min(min,head.val);
            max=Math.max(max,head.val);
        }

        //再次遍历，情况1：如果最大值最小值相同，说明在哪插入都一样，此时令新节点指向ans原本指向的下一个节点，并让ans的下一个节点指向新节点；
        if(min==max){
            t.next=ans.next;
            ans.next=t;
        }else{
            //情况2：如果最大最小值不同，当前节点(根据一次遍历，当前应该到达原链表的最后一个节点)因此，如果当前节点满足当前节点为最大值且下一个节点为最小值，则在该节点处插入新节点，先令新节点指向head原本指向的下一个节点，然后令head指向的节点变为新节点；
            while(!(head.val==max && head.next.val==min)){
                head=head.next;
            //情况3： 如果以上情况不满足，那么先判断插入值与极值的关系，如果超出了极值的范围，那么在当前位置插入即可，因为此时插入一定满足单调非减；
            //情况4：如果情况3也不满足，那么看该节点是否满足，当前节点值小于新节点值，且当前节点指向的下一个节点值大于新节点值，如果满足在该位置插入即可，否则对下一个节点进行判断
            }while(!(insertVal>=max || insertVal<=min) && !(insertVal>=head.val && insertVal<=head.next.val)){
                head=head.next;
            }
            t.next=head.next;
            head.next=t;
        }
        return ans;
    }
}
```
